# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1skBEg02HrnTaHva9GVmoY1wnX-wOrfX3
"""

"""
Blue Shirt â€” Streamlit Demo Frontend (demo-only)

Features:
- Buddy mood + scaled responses
- Daily Trio quests (generate, complete)
- XP calculation with balance multiplier, streak bonus, glitch XP
- Rest Mode enforcement (simulated active_hours)
- Crisis Mode & "Glitch XP" on comeback
- Local persistence: session_state + writes to 'user_data.json' (demo convenience)
- Simple star chart + rank tiers

This file is demo-only: it intentionally avoids real external integrations for safety & speed.
"""

import streamlit as st
from datetime import date, timedelta, datetime
import json
import os
from typing import List, Dict

# ---------------------------
# Config / Constants
# ---------------------------
USER_DATA_FILE = "user_data.json"
SEASON_DAYS = 60

RANK_TIERS = [
    ("Legendary", 5000),
    ("Master", 2500),
    ("Pro", 1200),
    ("Elite", 500),
    ("Veteran", 200),
    ("Rookie", 0),
]

DEFAULT_STATS = {
    "Knowledge": 10,
    "Guts": 8,
    "Proficiency": 9,
    "Kindness": 10,
    "Charm": 7,
}

BUDDY_LINES = {
    "High": "Boost mode ON. Letâ€™s stack 3 moves today â€” small, smart, legendary.",
    "Good": "Solid. Iâ€™ll keep the quests doable â€” a little challenge, a little shine.",
    "Low": "Soft mode activated. One small win beats a big skip. Want a 10-min warm-up quest?",
    "Low Battery": "Okay. Letâ€™s do one tiny thing: 5-minute walk or stretch. Main Character energy is also naps.",
    "Exhausted": "Cutscene time. Iâ€™m locking heavy quests. How about a breathing quest â€” just two minutes?",
}

# ---------------------------
# Utility functions
# ---------------------------
def load_user_data():
    if os.path.exists(USER_DATA_FILE):
        try:
            with open(USER_DATA_FILE, "r") as f:
                data = json.load(f)
                # convert last_active_date string to date?
                if isinstance(data.get("last_active_date"), str):
                    data["last_active_date"] = datetime.fromisoformat(data["last_active_date"]).date()
                return data
        except Exception:
            pass
    # default
    return {
        "user_id": "demo_user",
        "name": "Alex",
        "stats": DEFAULT_STATS.copy(),
        "xp_total": 0,
        "streak_days": 0,
        "last_active_date": None,
        "quests_today": [],
        "season_start": date.today().isoformat(),
    }

def save_user_data(state):
    # convert date to iso str for storage
    data = dict(state)
    if isinstance(data.get("last_active_date"), date):
        data["last_active_date"] = data["last_active_date"].isoformat()
    with open(USER_DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

def calc_rank_xp(base: int, categories_completed: int, streak_days: int, returned_after_miss: bool=False, mastery_bonus:int=0):
    balance = 1.25 if categories_completed >= 3 else 1.0
    streak_bonus = min(50, 5 * streak_days)
    glitch = 5 if returned_after_miss else 0
    return round(base * balance) + streak_bonus + glitch + mastery_bonus

def get_rank_name(xp_total: int) -> str:
    for name, thresh in RANK_TIERS:
        if xp_total >= thresh:
            return name
    return "Rookie"

def generate_daily_trio(preferred_stats: List[str]) -> List[Dict]:
    # deterministic-ish simple templates for demo
    templates = {
        "Knowledge": ("Study 30 mins", 30),
        "Guts": ("Talk to someone new / try new thing", 40),
        "Proficiency": ("Practice a skill for 20 mins", 35),
        "Kindness": ("Help someone (small act)", 20),
        "Charm": ("Groom & tidy for 10 mins", 15),
        "Vitality": ("Drink 2 glasses of water + 5-min stretch", 10)
    }
    trio = []
    # pick first two preferred stats and add a self-care
    picked = preferred_stats[:2] if preferred_stats else ["Knowledge", "Kindness"]
    for s in picked:
        title, xp = templates.get(s, ("Small task", 10))
        trio.append({"title": title, "stat": s, "base_xp": xp, "done": False})
    # self-care
    title, xp = templates["Vitality"]
    trio.append({"title": title, "stat": "Vitality", "base_xp": xp, "done": False})
    return trio

def distinct_categories_done(quests):
    cats = set()
    for q in quests:
        if q.get("done"):
            cats.add(q.get("stat"))
    return len(cats)

def start_of_today():
    return date.today()

# ---------------------------
# Initialization
# ---------------------------
st.set_page_config(page_title="Blue Shirt â€” Demo", page_icon="ğŸ•¶ï¸", layout="centered")

if "user" not in st.session_state:
    st.session_state.user = load_user_data()
    # ensure last_active_date is a date or None
    if isinstance(st.session_state.user.get("last_active_date"), str):
        st.session_state.user["last_active_date"] = datetime.fromisoformat(st.session_state.user["last_active_date"]).date()

# ensure quests_today exists and is for today
if not st.session_state.user.get("quests_today"):
    st.session_state.user["quests_today"] = generate_daily_trio(list(st.session_state.user["stats"].keys()))

# If stored season_start was a string, keep it
if isinstance(st.session_state.user.get("season_start"), str):
    pass

# ---------------------------
# Sidebar: user setup & controls
# ---------------------------
with st.sidebar:
    st.markdown("### Blue Shirt â€” Demo")
    name = st.text_input("Name", value=st.session_state.user.get("name", "Alex"))
    st.session_state.user["name"] = name

    st.markdown("**Choose an avatar (demo)**")
    avatar_choice = st.selectbox("Avatar", ["Sunglasses Kid", "Gamer Kid", "Sporty Kid", "Reader Kid"])
    st.session_state.user["avatar"] = avatar_choice

    st.markdown("---")
    st.markdown("**Parent / privacy**")
    parent_opt_in = st.checkbox("Parent weekly summary (demo)", value=False)
    st.session_state.user["parent_opt_in"] = parent_opt_in

    st.markdown("---")
    st.markdown("**Sim controls (demo only)**")
    # active_hours slider to simulate Rest Mode
    active_hours = st.slider("Simulated active hours today", 0, 24, 2)
    st.session_state.user["active_hours"] = active_hours

    if st.button("Simulate missed streak (set last active 3 days ago)"):
        st.session_state.user["last_active_date"] = date.today() - timedelta(days=3)
        st.success("Simulated missed activity. Crisis Mode will be visible if no action today.")

    if st.button("Reset demo data"):
        if os.path.exists(USER_DATA_FILE):
            os.remove(USER_DATA_FILE)
        st.session_state.user = load_user_data()
        st.session_state.user["quests_today"] = generate_daily_trio(list(st.session_state.user["stats"].keys()))
        st.experimental_rerun()

# ---------------------------
# Main UI
# ---------------------------
st.title("ğŸ•¶ï¸ Blue Shirt â€” Demo")
st.markdown("Put on the sunglasses â€” become the Main Character (demo).")
st.markdown("---")

col1, col2 = st.columns([2,1])
with col1:
    # Buddy & mood
    st.subheader("Buddy â€” Morning Vibe Check")
    mood = st.radio("How's the hardware feeling today?", ["High","Good","Low","Low Battery","Exhausted"], index=1, horizontal=True)
    if st.button("Ask Buddy"):
        buddy_text = BUDDY_LINES.get(mood, "Hey â€” ready for your quests?")
        # scale difficulty hint
        if mood == "High":
            difficulty_hint = "boost"
        elif mood == "Good":
            difficulty_hint = "base"
        elif mood == "Low":
            difficulty_hint = "soft"
        else:
            difficulty_hint = "micro-only"
        st.info(f"Buddy: {buddy_text}")
        st.caption(f"Suggested difficulty mode: **{difficulty_hint}**")

    # Crisis Mode detection
    last_active = st.session_state.user.get("last_active_date")
    if last_active is None:
        days_since = None
    else:
        days_since = (date.today() - last_active).days
    if days_since is None or days_since >= 2:
        st.warning("Crisis Mode: Looks like itâ€™s been a few days. Buddy suggests a micro-quest to avoid shame spirals.")
        if st.button("Do micro-quest (2-min breathing) â€” Claim Glitch XP"):
            # give glitch xp and micro quest reward
            gained = calc_rank_xp(base=5, categories_completed=1, streak_days=0, returned_after_miss=True)
            st.session_state.user["xp_total"] += gained
            st.session_state.user["last_active_date"] = date.today()
            st.session_state.user["streak_days"] = 1  # fresh comeback
            st.success(f"Nice! You earned {gained} XP (Glitch XP applied).")
            save_user_data(st.session_state.user)

    # Daily Trio
    st.subheader("Daily Trio â€” Quests")
    # Rest Mode enforcement: if active_hours >= 12 then lock heavy tasks (base_xp>=30)
    rest_locked = st.session_state.user.get("active_hours", 0) >= 12
    if rest_locked:
        st.info("Rest Mode: You've been active a long time â€” heavy quests are locked to prevent overuse.")

    quests = st.session_state.user["quests_today"]
    for idx, q in enumerate(quests):
        cols = st.columns([4,1,1])
        cols[0].markdown(f"**{q['title']}**  \n_Stat:_ {q['stat']}  â€¢  _Base XP:_ {q['base_xp']}")
        if q.get("done"):
            cols[1].success("Done")
            cols[2].button("Undo", key=f"undo_{idx}", on_click=lambda i=idx: undo_quest(i))
        else:
            disabled = False
            # lock if Rest Mode and heavy
            if rest_locked and q["base_xp"] >= 30:
                disabled = True
            if cols[2].button("Complete", key=f"do_{idx}"):
                # complete quest logic
                # determine categories completed BEFORE marking this quest done
                cats_done_before = distinct_categories_done(quests)
                # compute returned_after_miss flag
                last_active = st.session_state.user.get("last_active_date")
                returned_after_miss = False
                if last_active is None:
                    returned_after_miss = True
                else:
                    days_since_last = (date.today() - last_active).days
                    if days_since_last >= 2:
                        returned_after_miss = True
                # mark done
                quests[idx]["done"] = True
                st.session_state.user["quests_today"] = quests
                # compute xp
                categories_after = distinct_categories_done(quests)
                gained = calc_rank_xp(base=q["base_xp"], categories_completed=categories_after, streak_days=st.session_state.user.get("streak_days",0), returned_after_miss=returned_after_miss)
                st.session_state.user["xp_total"] += gained
                # streak logic
                if last_active is None:
                    st.session_state.user["streak_days"] = 1
                else:
                    if (date.today() - last_active).days == 1:
                        st.session_state.user["streak_days"] = st.session_state.user.get("streak_days", 0) + 1
                    elif (date.today() - last_active).days == 0:
                        # same day, keep streak
                        pass
                    else:
                        # comeback after miss
                        st.session_state.user["streak_days"] = 1
                st.session_state.user["last_active_date"] = date.today()
                st.success(f"Completed: +{gained} XP")
                save_user_data(st.session_state.user)
    st.markdown("---")

    if st.button("Regenerate Today's Trio (demo)"):
        st.session_state.user["quests_today"] = generate_daily_trio(list(st.session_state.user["stats"].keys()))
        save_user_data(st.session_state.user)
        st.experimental_rerun()

with col2:
    # Overview box
    st.subheader("Hero Snapshot")
    st.markdown(f"**{st.session_state.user['name']}** â€” Avatar: {st.session_state.user.get('avatar')}")
    st.markdown(f"**Total XP:** {st.session_state.user.get('xp_total', 0)}  \n**Streak:** {st.session_state.user.get('streak_days', 0)} day(s)")
    rank = get_rank_name(st.session_state.user.get("xp_total", 0))
    st.markdown(f"**Rank:** {rank}")
    st.markdown("---")
    st.subheader("Star Chart â€” Stats")
    # show stats as bar chart
    chart_data = {
        "stat": list(st.session_state.user["stats"].keys()),
        "value": [v for v in st.session_state.user["stats"].values()]
    }
    st.bar_chart(data=chart_data["value"], x=chart_data["stat"]) if False else st.write(st.session_state.user["stats"])  # bar_chart with labels is awkward; show dict for clarity

    st.markdown("---")
    st.subheader("Season")
    season_start = st.session_state.user.get("season_start")
    st.markdown(f"Season started: {season_start}")
    days_into = (date.today() - date.fromisoformat(season_start)).days if isinstance(season_start, str) else 0
    st.markdown(f"Day {days_into+1} of {SEASON_DAYS}")

    st.markdown("---")
    st.subheader("Quick actions (demo)")
    if st.button("Give demo Glitch XP (simulate comeback)"):
        st.session_state.user["xp_total"] += 5
        st.session_state.user["last_active_date"] = date.today()
        st.session_state.user["streak_days"] = 1
        save_user_data(st.session_state.user)
        st.success("Added 5 Glitch XP for demo comeback.")
    if st.button("Lock sunglasses (force Rest Mode)"):
        st.session_state.user["active_hours"] = 12
        save_user_data(st.session_state.user)
        st.experimental_rerun()

# ---------------------------
# Helpers defined after UI elements to allow button callbacks to find them
# ---------------------------
def undo_quest(idx):
    quests = st.session_state.user["quests_today"]
    if 0 <= idx < len(quests):
        quests[idx]["done"] = False
        st.session_state.user["quests_today"] = quests
        save_user_data(st.session_state.user)
        st.experimental_rerun()

# ---------------------------
# Footer: tips & save state
# ---------------------------
st.markdown("---")
st.markdown("**Demo tips:** Use the sidebar to simulate rest/active hours or missed streaks. This demo keeps data in `user_data.json` for convenience â€” delete it to reset.")
# Save user data on every run for demo convenience
save_user_data(st.session_state.user)